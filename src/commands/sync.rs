use cliclack::log;
use miette::{IntoDiagnostic, Result};
use owo_colors::OwoColorize;
use serde::Deserialize;
use std::path::Path;

use crate::config::agent_config_dir;
use crate::error::WaiError;

use super::require_project;

#[derive(Debug, Deserialize)]
struct ProjectionsConfig {
    #[serde(default)]
    projections: Vec<Projection>,
}

#[derive(Debug, Deserialize)]
struct Projection {
    target: String,
    strategy: String,
    #[serde(default)]
    sources: Vec<String>,
}

pub fn run(status_only: bool) -> Result<()> {
    let project_root = require_project()?;
    let config_dir = agent_config_dir(&project_root);
    let projections_path = config_dir.join(".projections.yml");

    if !projections_path.exists() {
        return Err(WaiError::ConfigSyncError {
            message: "No .projections.yml found in agent-config directory".to_string(),
        }
        .into());
    }

    let content = std::fs::read_to_string(&projections_path).into_diagnostic()?;
    let config: ProjectionsConfig = serde_yaml::from_str(&content)
        .map_err(|e| crate::error::WaiError::ConfigError {
            message: format!("Invalid .projections.yml: {}", e),
        })?;

    if config.projections.is_empty() {
        println!();
        println!(
            "  {} No projections configured.",
            "○".dimmed()
        );
        println!(
            "  {} Edit .wai/resources/agent-config/.projections.yml to add projections",
            "→".dimmed()
        );
        println!();
        return Ok(());
    }

    if status_only {
        println!();
        println!("  {} Sync Status", "◆".cyan());
        for proj in &config.projections {
            let target_path = project_root.join(&proj.target);
            let exists = target_path.exists();
            let status = if exists {
                "synced".green().to_string()
            } else {
                "not synced".yellow().to_string()
            };
            println!(
                "    {} {} → {} [{}]",
                "•".dimmed(),
                proj.sources.join(", "),
                proj.target,
                status
            );
        }
        println!();
        return Ok(());
    }

    // Execute projections
    for proj in &config.projections {
        match proj.strategy.as_str() {
            "symlink" => execute_symlink(&project_root, &config_dir, proj)?,
            "inline" => execute_inline(&project_root, &config_dir, proj)?,
            "reference" => execute_reference(&project_root, &config_dir, proj)?,
            other => {
                log::warning(format!("Unknown strategy '{}' for target '{}'", other, proj.target))
                    .into_diagnostic()?;
            }
        }
    }

    log::success("Agent configs synced").into_diagnostic()?;
    Ok(())
}

fn execute_symlink(
    project_root: &Path,
    config_dir: &Path,
    proj: &Projection,
) -> Result<()> {
    let target = project_root.join(&proj.target);

    if target.exists() {
        std::fs::remove_dir_all(&target).into_diagnostic()?;
    }

    // For directory targets, create parent and symlink each source
    std::fs::create_dir_all(&target).into_diagnostic()?;

    for source in &proj.sources {
        let source_path = config_dir.join(source);
        if source_path.exists() && source_path.is_dir() {
            for entry in std::fs::read_dir(&source_path).into_diagnostic()? {
                let entry = entry.into_diagnostic()?;
                let link_path = target.join(entry.file_name());
                #[cfg(unix)]
                std::os::unix::fs::symlink(entry.path(), &link_path).into_diagnostic()?;
                #[cfg(not(unix))]
                std::fs::copy(entry.path(), &link_path).into_diagnostic()?;
            }
        }
    }

    log::info(format!("Symlinked → {}", proj.target)).into_diagnostic()?;
    Ok(())
}

fn execute_inline(
    project_root: &Path,
    config_dir: &Path,
    proj: &Projection,
) -> Result<()> {
    let target = project_root.join(&proj.target);
    let mut content = String::from("# Auto-generated by wai — do not edit directly\n\n");

    for source in &proj.sources {
        let source_path = config_dir.join(source);
        if source_path.exists() {
            if source_path.is_dir() {
                let mut entries: Vec<_> = std::fs::read_dir(&source_path)
                    .into_diagnostic()?
                    .filter_map(|e| e.ok())
                    .collect();
                entries.sort_by_key(|e| e.file_name());

                for entry in entries {
                    if let Ok(file_content) = std::fs::read_to_string(entry.path()) {
                        content.push_str(&format!(
                            "# Source: {}/{}\n",
                            source,
                            entry.file_name().to_str().unwrap_or("?")
                        ));
                        content.push_str(&file_content);
                        content.push_str("\n\n");
                    }
                }
            } else if let Ok(file_content) = std::fs::read_to_string(&source_path) {
                content.push_str(&format!("# Source: {}\n", source));
                content.push_str(&file_content);
                content.push_str("\n\n");
            }
        }
    }

    if let Some(parent) = target.parent() {
        std::fs::create_dir_all(parent).into_diagnostic()?;
    }
    std::fs::write(&target, content).into_diagnostic()?;

    log::info(format!("Inlined → {}", proj.target)).into_diagnostic()?;
    Ok(())
}

fn execute_reference(
    project_root: &Path,
    config_dir: &Path,
    proj: &Projection,
) -> Result<()> {
    let target = project_root.join(&proj.target);
    let mut content = String::from("# Auto-generated by wai — do not edit directly\n");
    content.push_str("# References to agent config sources:\n\n");

    for source in &proj.sources {
        let source_path = config_dir.join(source);
        if source_path.exists() && source_path.is_dir() {
            let mut entries: Vec<_> = std::fs::read_dir(&source_path)
                .into_diagnostic()?
                .filter_map(|e| e.ok())
                .collect();
            entries.sort_by_key(|e| e.file_name());

            for entry in entries {
                if let Some(name) = entry.file_name().to_str() {
                    content.push_str(&format!(
                        "- .wai/resources/agent-config/{}/{}\n",
                        source, name
                    ));
                }
            }
        }
    }

    if let Some(parent) = target.parent() {
        std::fs::create_dir_all(parent).into_diagnostic()?;
    }
    std::fs::write(&target, content).into_diagnostic()?;

    log::info(format!("Referenced → {}", proj.target)).into_diagnostic()?;
    Ok(())
}
