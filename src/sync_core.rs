//! Core sync execution functions for agent config projections.
//!
//! These functions implement the three projection strategies (symlink, inline, reference)
//! without CLI-specific concerns like safe mode checks or user-facing output formatting.
//! They can be used by both the `wai sync` command and `wai doctor --fix`.

use cliclack::log;
use miette::{IntoDiagnostic, Result};
use serde::Deserialize;
use std::path::Path;

#[derive(Debug, Deserialize)]
pub(crate) struct Projection {
    pub target: String,
    pub strategy: String,
    #[serde(default)]
    pub sources: Vec<String>,
}

/// Execute a symlink projection: create target directory and symlink each source file into it.
pub(crate) fn execute_symlink(
    project_root: &Path,
    config_dir: &Path,
    proj: &Projection,
) -> Result<()> {
    let target = project_root.join(&proj.target);

    if target.exists() {
        std::fs::remove_dir_all(&target).into_diagnostic()?;
    }

    // For directory targets, create parent and symlink each source
    std::fs::create_dir_all(&target).into_diagnostic()?;

    for source in &proj.sources {
        let source_path = config_dir.join(source);
        if source_path.exists() && source_path.is_dir() {
            for entry in std::fs::read_dir(&source_path).into_diagnostic()? {
                let entry = entry.into_diagnostic()?;
                let link_path = target.join(entry.file_name());
                #[cfg(unix)]
                std::os::unix::fs::symlink(entry.path(), &link_path).into_diagnostic()?;
                #[cfg(not(unix))]
                std::fs::copy(entry.path(), &link_path).into_diagnostic()?;
            }
        }
    }

    log::info(format!("Symlinked → {}", proj.target)).into_diagnostic()?;
    Ok(())
}

/// Execute an inline projection: concatenate source files into a single target file.
pub(crate) fn execute_inline(
    project_root: &Path,
    config_dir: &Path,
    proj: &Projection,
) -> Result<()> {
    let target = project_root.join(&proj.target);
    let mut content = String::from("# Auto-generated by wai — do not edit directly\n\n");

    for source in &proj.sources {
        let source_path = config_dir.join(source);
        if source_path.exists() {
            if source_path.is_dir() {
                let mut entries: Vec<_> = std::fs::read_dir(&source_path)
                    .into_diagnostic()?
                    .filter_map(|e| e.ok())
                    .collect();
                entries.sort_by_key(|e| e.file_name());

                for entry in entries {
                    if let Ok(file_content) = std::fs::read_to_string(entry.path()) {
                        content.push_str(&format!(
                            "# Source: {}/{}\n",
                            source,
                            entry.file_name().to_str().unwrap_or("?")
                        ));
                        content.push_str(&file_content);
                        content.push_str("\n\n");
                    }
                }
            } else if let Ok(file_content) = std::fs::read_to_string(&source_path) {
                content.push_str(&format!("# Source: {}\n", source));
                content.push_str(&file_content);
                content.push_str("\n\n");
            }
        }
    }

    if let Some(parent) = target.parent() {
        std::fs::create_dir_all(parent).into_diagnostic()?;
    }
    std::fs::write(&target, content).into_diagnostic()?;

    log::info(format!("Inlined → {}", proj.target)).into_diagnostic()?;
    Ok(())
}

/// Execute a reference projection: create a file listing references to source files.
pub(crate) fn execute_reference(
    project_root: &Path,
    config_dir: &Path,
    proj: &Projection,
) -> Result<()> {
    let target = project_root.join(&proj.target);
    let mut content = String::from("# Auto-generated by wai — do not edit directly\n");
    content.push_str("# References to agent config sources:\n\n");

    for source in &proj.sources {
        let source_path = config_dir.join(source);
        if source_path.exists() && source_path.is_dir() {
            let mut entries: Vec<_> = std::fs::read_dir(&source_path)
                .into_diagnostic()?
                .filter_map(|e| e.ok())
                .collect();
            entries.sort_by_key(|e| e.file_name());

            for entry in entries {
                if let Some(name) = entry.file_name().to_str() {
                    content.push_str(&format!(
                        "- .wai/resources/agent-config/{}/{}\n",
                        source, name
                    ));
                }
            }
        }
    }

    if let Some(parent) = target.parent() {
        std::fs::create_dir_all(parent).into_diagnostic()?;
    }
    std::fs::write(&target, content).into_diagnostic()?;

    log::info(format!("Referenced → {}", proj.target)).into_diagnostic()?;
    Ok(())
}
